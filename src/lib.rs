use std::net::{ IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr };

mod error;
mod socket;
pub use error::*;

/// Maximum length of an instance name
pub const MAX_INSTANCE_NAME_LEN: usize = 32;

/// The CLNT_BCAST_EX packet is a broadcast or multicast request that is generated by clients that are trying 
/// to identify the list of database instances on the network and their network protocol connection information.
const CLNT_BCAST_EX: u8 = 0x02;

/// The CLNT_UCAST_EX packet is a unicast request that is generated by clients that are trying to identify 
/// the list of database instances and their network protocol connection information installed on a single machine. 
const CLNT_UCAST_EX: u8 = 0x03;

/// The CLNT_UCAST_INST packet is a request for information related to a specific instance.
const CLNT_UCAST_INST: u8 = 0x04;

/// The CLNT_UCAST_DAC packet request is used to determine the TCP [RFC793] port on which the 
/// Microsoft SQL Server dedicated administrator connection (DAC) endpoint is listening.
const CLNT_UCAST_DAC: u8 = 0x0F;

/// The server responds to all client requests with an SVR_RESP. 
const SVR_RESP: u8 = 0x05;

/// Information send in a browser protocol response
/// See https://docs.microsoft.com/en-us/openspecs/windows_protocols/mc-sqlr/2e1560c9-5097-4023-9f5e-72b9ff1ec3b1
#[derive(Debug)]
pub struct InstanceInfo {
    /// The address of the instance
    pub addr: IpAddr,

    /// The name of the server. The SERVERNAME MUST be no greater than 255 bytes.
    pub server_name: String,

    /// A text string that represents the name of the server instance being described. 
    /// The INSTANCENAME MUST be no greater than 255 bytes but SHOULD be no greater than 16 MBCS characters.
    pub instance_name: String,

    pub is_clustered: bool,
    
    /// A text string that conveys the version of the server instance. The VERSION_STRING MUST be no greater than 16 bytes. 
    /// VERSION_STRING MUST NOT be empty and MUST appear as follows: VERSION_STRING=1*[0-9"."]
    pub version: String,

    pub np_info: Option<NamedPipeInfo>,
    pub tcp_info: Option<TcpInfo>,
    pub via_info: Option<ViaInfo>,
    pub rpc_info: Option<RpcInfo>,
    pub spx_info: Option<SpxInfo>,
    pub adsp_info: Option<AdspInfo>,
    pub bv_info: Option<BvInfo>
}

/// Information about the named pipe endpoint
#[derive(Debug)]
pub struct NamedPipeInfo {
    /// A text string that represents the pipe name.
    pub name: String
}

/// Information about the Tcp endpoint
#[derive(Debug)]
pub struct TcpInfo {
    /// A text string that represents the decimal value of the TCP port that is used to connect to the requested server instance.
    /// TCP_PORT SHOULD be a valid TCP port as specified in \[RFC793\]
    pub port: u16
}

/// Information about the Virtual Interface Architecture endpoint
#[derive(Debug)]
pub struct ViaInfo {
    /// A text string that MUST be no greater than 15 bytes and that represents the NetBIOS name of a machine where the server resides.
    pub machine_name: String,
    
    /// The VIA addresses specified
    pub addresses: Vec<ViaAddress>
}

/// A combination of NIC name and port.
#[derive(Debug)]
pub struct ViaAddress {
    /// A text string that represents the VIA network interface card (NIC) identifier. 
    /// VIANIC SHOULD be a valid VIA Adapter NIC number \[VIA2002\].
    pub nic: String,

    /// A text string that represents the decimal value of the VIA NIC's port. 
    /// VIAPORT SHOULD be a valid VIA Adapter port number \[VIA2002\].
    pub port: String
}

/// Contains information about an RPC endpoint
#[derive(Debug)]
pub struct RpcInfo {
    /// The name of the computer to connect to. SHOULD be no more than 127 MBCS characters.
    pub computer_name: String
}

/// Contains information about an SPX service endpoint
#[derive(Debug)]
pub struct SpxInfo {
    /// The SPX service name of the server. 
    /// MUST NOT be greater than 1,024 bytes and SHOULD be no more than 127 MBCS characters.
    pub service_name: String
}

/// Contains information about an AppleTalk endpoint
#[derive(Debug)]
pub struct AdspInfo {
    /// The AppleTalk service object name. SHOULD be no more than 127 MBCS characters.
    pub object_name: String
}

/// Contains information about an Banyan VINES endpoint
#[derive(Debug)]
pub struct BvInfo {
    /// The Banyan VINES item name. SHOULD be no more than 127 MBCS characters.
    pub item_name: String,
    
    /// The Banyan VINES group name. SHOULD be no more than 127 MBCS characters.
    pub group_name: String,
    
    /// The Banyan VINES organization name. SHOULD be no more than 127 MBCS characters.
    pub org_name: String
}

/// Contains information about the DAC endpoint of an instance
#[derive(Debug)]
pub struct DacInfo {
    port: u16
}

/// Supplies instance information as they arrive
pub struct AsyncInstanceIterator<UdpSocket: socket::UdpSocket> {
    socket: UdpSocket,
    buffer: Vec<u8>,

    current_remote_addr: IpAddr,
    current_offset: usize
}

impl<UdpSocket: socket::UdpSocket> AsyncInstanceIterator<UdpSocket> {
    /// Gets the next received instance information. You can call this method multiple
    /// times to receive information about multiple instances until it returns Ok(None).
    pub async fn next(&mut self) -> Result<Option<InstanceInfo>, BrowserError<UdpSocket::Error>> {
        loop {
            if self.current_offset >= self.buffer.len() {
                // Need to receive a new packet
                // TODO: Find a way to determine buffer size based on FIONREAD
                // once/if ever tokio supports it
                self.buffer.resize_with(65535 + 3, Default::default);

                let (bytes_received, remote_addr) = self.socket.recv_from(&mut self.buffer)
                    .await
                    .map_err(BrowserError::ReceiveFailed)?;

                self.current_remote_addr = remote_addr.ip();

                if bytes_received < 3 || self.buffer[0] != SVR_RESP {
                    self.current_offset = std::usize::MAX;
                    continue;
                }

                let resp_data_len = u16::from_le_bytes([self.buffer[1], self.buffer[2]]);
                if resp_data_len as usize != bytes_received - 3 {
                    self.current_offset = std::usize::MAX;
                    continue;
                }

                // Validate that the buffer is valid utf-8
                // TODO: Decode mbcs string
                if std::str::from_utf8(&self.buffer[3..]).is_err() {
                    self.current_offset = std::usize::MAX;
                    continue;
                }

                self.buffer.truncate(bytes_received);
                self.current_offset = 3;
            }

            // UNSAFE: Buffer is already validated to be valid utf-8 when the iterator was created
            let as_str = unsafe { std::str::from_utf8_unchecked(&self.buffer[self.current_offset..]) };

            let (instance, consumed) = match parse_instance_info(self.current_remote_addr, as_str) {
                Ok(x) => x,
                Err(_) => {
                    self.current_offset = std::usize::MAX;
                    continue;
                }
            };

            self.current_offset += consumed;
            return Ok(Some(instance));
        }
    }
}

/// Iterates over the instances returned by a single host
pub struct InstanceIterator {
    remote_addr: IpAddr,
    buffer: Vec<u8>,
    offset: usize
}

impl InstanceIterator {
    /// Gets the next received instance information. You can call this method multiple
    /// times to receive information about multiple instances until it returns Ok(None).
    pub fn next(&mut self) -> Result<Option<InstanceInfo>, BrowserError<std::convert::Infallible>> {
        if self.offset == self.buffer.len() {
            return Ok(None);
        }

        // UNSAFE: Buffer is already validated to be valid utf-8 when the iterator was created
        let as_str = unsafe { std::str::from_utf8_unchecked(&self.buffer[self.offset..]) };
        let (instance, consumed) = parse_instance_info(self.remote_addr, as_str)
            .map_err(|e| BrowserError::ProtocolError(e))?;

        self.offset += consumed;
        Ok(Some(instance))
    }
}

/// Discovers any SQL Server instances running on hosts reached by
/// the given multicast address.
/// 
/// # Arguments
/// * `multicast_addr` - A multicast address to which to broadcast the browse datagram.
///                      This can be the Ipv4 BROADCAST address, or a Ipv6 multicast address.
#[cfg(feature = "tokio")]
pub async fn browse(multicast_addr: IpAddr) -> Result<AsyncInstanceIterator<tokio::net::UdpSocket>, BrowserError<tokio::io::Error>> {
    custom_socket::browse::<tokio::net::UdpSocket>(multicast_addr).await
}

/// Discovers any SQL Server instances running on hosts reached by
/// the given multicast address.
/// 
/// # Arguments
/// * `multicast_addr` - A multicast address to which to broadcast the browse datagram.
///                      This can be the Ipv4 BROADCAST address, or a Ipv6 multicast address.
#[cfg(feature = "async_std")]
pub async fn browse(multicast_addr: IpAddr) -> Result<AsyncInstanceIterator<async_std::net::UdpSocket>, BrowserError<async_std::io::Error>> {
    custom_socket::browse::<async_std::net::UdpSocket>(multicast_addr).await
}

/// Discovers any SQL Server instances running on the given host
/// 
/// # Arguments
/// * `remote_addr` - The address of the remote host of which to retrieve information
///                   about the instances running on it.
#[cfg(feature = "tokio")]
pub async fn browse_host(remote_addr: IpAddr) -> Result<InstanceIterator, BrowserError<tokio::io::Error>> {
    custom_socket::browse_host::<tokio::net::UdpSocket>(remote_addr).await
}

/// Discovers any SQL Server instances running on the given host
/// 
/// # Arguments
/// * `remote_addr` - The address of the remote host of which to retrieve information
///                   about the instances running on it.
#[cfg(feature = "async_std")]
pub async fn browse_host(remote_addr: IpAddr) -> Result<InstanceIterator, BrowserError<async_std::io::Error>> {
    custom_socket::browse_host::<async_std::net::UdpSocket>(remote_addr).await
}

/// Gets information about the given instance.
/// 
/// # Arguments
/// * `remote_addr` - The address of the remote host on which the instance is running.
/// * `instance_name` - The name of the instance, must be less than `MAX_INSTANCE_NAME_LEN` characters.
#[cfg(feature = "tokio")]
pub async fn browse_instance(remote_addr: IpAddr, instance_name: &str) -> Result<InstanceInfo, BrowserError<tokio::io::Error>> {
    custom_socket::browse_instance::<tokio::net::UdpSocket>(remote_addr, instance_name).await
}

/// Gets information about the given instance.
/// 
/// # Arguments
/// * `remote_addr` - The address of the remote host on which the instance is running.
/// * `instance_name` - The name of the instance, must be less than `MAX_INSTANCE_NAME_LEN` characters.
#[cfg(feature = "async_std")]
pub async fn browse_instance(remote_addr: IpAddr, instance_name: &str) -> Result<InstanceInfo, BrowserError<async_std::io::Error>> {
    custom_socket::browse_instance::<async_std::net::UdpSocket>(remote_addr, instance_name).await
}

/// Gets DAC information about the given instance
/// 
/// # Arguments
/// * `remote_addr` - The address of the remote host on which the instance is running.
/// * `instance_name` - The name of the instance, must be less than `MAX_INSTANCE_NAME_LEN` characters.
#[cfg(feature = "tokio")]
pub async fn browse_instance_dac(remote_addr: IpAddr, instance_name: &str) -> Result<DacInfo, BrowserError<tokio::io::Error>> {
    custom_socket::browse_instance_dac::<tokio::net::UdpSocket>(remote_addr, instance_name).await
}

/// Gets DAC information about the given instance
/// 
/// # Arguments
/// * `remote_addr` - The address of the remote host on which the instance is running.
/// * `instance_name` - The name of the instance, must be less than `MAX_INSTANCE_NAME_LEN` characters.
#[cfg(feature = "async_std")]
pub async fn browse_instance_dac(remote_addr: IpAddr, instance_name: &str) -> Result<DacInfo, BrowserError<async_std::io::Error>> {
    custom_socket::browse_instance_dac::<async_std::net::browse_instance>(remote_addr, instance_name).await
}

/// Implementations of the different browse methods that allow
/// specifying a custom socket implementation.
pub mod custom_socket {
    pub use super::socket::*;
    use super::*;

    /// Discovers any SQL Server instances running on hosts reached by
    /// the given multicast address.
    /// 
    /// # Arguments
    /// * `multicast_addr` - A multicast address to which to broadcast the browse datagram.
    ///                      This can be the Ipv4 BROADCAST address, or a Ipv6 multicast address.
    pub async fn browse<UdpSocket: socket::UdpSocket>(multicast_addr: IpAddr) -> Result<AsyncInstanceIterator<UdpSocket>, BrowserError<UdpSocket::Error>> {
        let local_addr = if multicast_addr.is_ipv4() {
            IpAddr::V4(Ipv4Addr::UNSPECIFIED)
        }
        else {
            IpAddr::V6(Ipv6Addr::UNSPECIFIED)
        };

        let bind_to = SocketAddr::new(local_addr, 0);
        let mut socket = UdpSocket::bind(&bind_to).await
            .map_err(BrowserError::BindFailed)?;

        socket.enable_broadcast()
            .await
            .map_err(BrowserError::SetBroadcastFailed)?;

        let buffer = [CLNT_BCAST_EX]; 
        let remote = SocketAddr::new(multicast_addr, 1434);
        socket.send_to(&buffer, &remote).await
            .map_err(|e| BrowserError::SendFailed(remote, e))?;

        Ok(AsyncInstanceIterator {
            socket: socket,
            buffer: Vec::new(),
            current_remote_addr: IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)),
            current_offset: 0
        })
    }

    /// Discovers any SQL Server instances running on the given host
    /// 
    /// # Arguments
    /// * `remote_addr` - The address of the remote host of which to retrieve information
    ///                   about the instances running on it.
    pub async fn browse_host<UdpSocket: socket::UdpSocket>(remote_addr: IpAddr) -> Result<InstanceIterator, BrowserError<UdpSocket::Error>> {
        let local_addr = if remote_addr.is_ipv4() {
            IpAddr::V4(Ipv4Addr::UNSPECIFIED)
        }
        else {
            IpAddr::V6(Ipv6Addr::UNSPECIFIED)
        };

        let bind_to = SocketAddr::new(local_addr, 0);
        let mut socket = UdpSocket::bind(&bind_to).await
            .map_err(BrowserError::BindFailed)?;

        let remote = SocketAddr::new(remote_addr, 1434);
        socket.connect(&remote).await
            .map_err(|e| BrowserError::ConnectFailed(remote, e))?;

        let buffer = [CLNT_UCAST_EX];
        socket.send_to(&buffer, &remote).await
            .map_err(|e| BrowserError::SendFailed(remote, e))?;

        let mut buffer = Vec::with_capacity(65535 + 3);
        
        buffer.resize_with(buffer.capacity(), Default::default);

        let bytes_received = socket.recv(&mut buffer).await
            .map_err(BrowserError::ReceiveFailed)?;

        if bytes_received < 1 {
            return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::MessageIdentifier(SVR_RESP),
                found: BrowserProtocolToken::EndOfMessage   
            }));
        }

        if buffer[0] != SVR_RESP {
            return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::MessageIdentifier(SVR_RESP),
                found: BrowserProtocolToken::MessageIdentifier(buffer[0])
            }));
        }

        if bytes_received < 3 {
            return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::MessageLength,
                found: BrowserProtocolToken::EndOfMessage
            }));
        }

        let resp_data_len = u16::from_le_bytes([buffer[1], buffer[2]]);
        if resp_data_len as usize != bytes_received - 3 {
            return Err(BrowserError::ProtocolError(BrowserProtocolError::LengthMismatch {
                datagram: bytes_received,
                header: (resp_data_len + 3) as usize
            }));
        }

        buffer.truncate(bytes_received);

        // Validate that the buffer is valid utf-8
        // TODO: Decode mbcs string
        std::str::from_utf8(&buffer[3..])
            .map_err(|e| BrowserError::ProtocolError(BrowserProtocolError::InvalidUtf8(e)))?;

        Ok(InstanceIterator {
            remote_addr,
            buffer,
            offset: 3
        })
    }

    /// Gets information about the given instance.
    /// 
    /// # Arguments
    /// * `remote_addr` - The address of the remote host on which the instance is running.
    /// * `instance_name` - The name of the instance, must be less than `MAX_INSTANCE_NAME_LEN` characters.
    pub async fn browse_instance<UdpSocket: socket::UdpSocket>(remote_addr: IpAddr, instance_name: &str) -> Result<InstanceInfo, BrowserError<UdpSocket::Error>> {
        if instance_name.len() > MAX_INSTANCE_NAME_LEN {
            return Err(BrowserError::InstanceNameTooLong);
        }

        let local_addr = if remote_addr.is_ipv4() {
            IpAddr::V4(Ipv4Addr::UNSPECIFIED)
        }
        else {
            IpAddr::V6(Ipv6Addr::UNSPECIFIED)
        };

        let bind_to = SocketAddr::new(local_addr, 0);
        let mut socket = UdpSocket::bind(&bind_to).await
            .map_err(BrowserError::BindFailed)?;

        let remote = SocketAddr::new(remote_addr, 1434);
        socket.connect(&remote).await
            .map_err(|e| BrowserError::ConnectFailed(remote, e))?;

        let mut buffer = [0u8; 1 + MAX_INSTANCE_NAME_LEN + 1];
        buffer[0] = CLNT_UCAST_INST;
        buffer[1..(1+instance_name.len())].copy_from_slice(instance_name.as_bytes()); // TODO: Encode as mbcs string
        let buffer_len = 2 + instance_name.len();
        socket.send_to(&buffer[0..buffer_len], &remote).await
            .map_err(|e| BrowserError::SendFailed(remote, e))?;

        let mut buffer = [0u8; 3 + 1024];

        let bytes_received = socket.recv(&mut buffer).await
            .map_err(BrowserError::ReceiveFailed)?;

        if bytes_received < 1 {
            return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::MessageIdentifier(SVR_RESP),
                found: BrowserProtocolToken::EndOfMessage   
            }));
        }

        if buffer[0] != SVR_RESP {
            return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::MessageIdentifier(SVR_RESP),
                found: BrowserProtocolToken::MessageIdentifier(buffer[0])   
            }));
        }

        if bytes_received < 3 {
            return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::MessageLength,
                found: BrowserProtocolToken::EndOfMessage
            }));
        }

        let resp_data_len = u16::from_le_bytes([buffer[1], buffer[2]]);
        if resp_data_len as usize != bytes_received - 3 {
            return Err(BrowserError::ProtocolError(BrowserProtocolError::LengthMismatch {
                datagram: bytes_received,
                header: (resp_data_len + 3) as usize
            }));
        }

        // TODO: Decode mbcs string
        let as_str = std::str::from_utf8(&buffer[3..bytes_received]).unwrap();
        let (instance, consumed) = parse_instance_info(remote_addr, &as_str)
            .map_err(|e| BrowserError::ProtocolError(e))?;
        
        if consumed != as_str.len() {
            return Err(BrowserError::ProtocolError(BrowserProtocolError::ExtraneousData(Vec::from(&buffer[(3 + consumed)..]))));
        }

        Ok(instance)
    }

    /// Gets DAC information about the given instance
    /// 
    /// # Arguments
    /// * `remote_addr` - The address of the remote host on which the instance is running.
    /// * `instance_name` - The name of the instance, must be less than `MAX_INSTANCE_NAME_LEN` characters.
    pub async fn browse_instance_dac<UdpSocket: socket::UdpSocket>(remote_addr: IpAddr, instance_name: &str) -> Result<DacInfo, BrowserError<UdpSocket::Error>> {
        const VERSION: u8 = 0x01;

        if instance_name.len() > MAX_INSTANCE_NAME_LEN {
            return Err(BrowserError::InstanceNameTooLong);
        }

        let local_addr = if remote_addr.is_ipv4() {
            IpAddr::V4(Ipv4Addr::UNSPECIFIED)
        }
        else {
            IpAddr::V6(Ipv6Addr::UNSPECIFIED)
        };

        let bind_to = SocketAddr::new(local_addr, 0);
        let mut socket = UdpSocket::bind(&bind_to).await
            .map_err(BrowserError::BindFailed)?;

        let remote = SocketAddr::new(remote_addr, 1434);
        socket.connect(&remote).await
            .map_err(|e| BrowserError::ConnectFailed(remote, e))?;
    
        let mut buffer = [0u8; 2 + MAX_INSTANCE_NAME_LEN + 1];
        buffer[0] = CLNT_UCAST_DAC;
        buffer[1] = VERSION;
        buffer[2..(2+instance_name.len())].copy_from_slice(instance_name.as_bytes()); // TODO: Encode as mbcs string
        let buffer_len = 3 + instance_name.len();
        socket.send(&buffer[0..buffer_len]).await
            .map_err(|e| BrowserError::SendFailed(remote, e))?;

        let mut buffer = [0u8; 6];

        let bytes_received = socket.recv(&mut buffer).await
            .map_err(BrowserError::ReceiveFailed)?;

        if bytes_received < 1 {
            return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::MessageIdentifier(SVR_RESP),
                found: BrowserProtocolToken::EndOfMessage   
            }));
        }

        if buffer[0] != SVR_RESP {
            return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::MessageIdentifier(SVR_RESP),
                found: BrowserProtocolToken::MessageIdentifier(buffer[0])   
            }));
        }

        if bytes_received < 3 {
            return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::MessageLength,
                found: BrowserProtocolToken::EndOfMessage
            }));
        }

        let packet_size = u16::from_le_bytes([buffer[1], buffer[2]]) as usize;
        if packet_size != buffer.len() {
            return Err(BrowserError::ProtocolError(BrowserProtocolError::LengthMismatch {
                datagram: bytes_received,
                header: packet_size
            }));
        }

        if bytes_received < 4 {
            return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::DacVersion(VERSION),
                found: BrowserProtocolToken::EndOfMessage
            }));
        }

        if buffer[3] != VERSION {
            return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::DacVersion(VERSION),
                found: BrowserProtocolToken::DacVersion(buffer[3])
            }));
        }

        if bytes_received < 6 {
            return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::DacPort,
                found: BrowserProtocolToken::EndOfMessage
            }));
        }

        let port = u16::from_le_bytes([buffer[4], buffer[5]]);
        return Ok(DacInfo { port });
    }
}

struct SplitIteratorWithPosition<'a> {
    inner: std::str::Split<'a, char>,
    position: usize
}

impl<'a> SplitIteratorWithPosition<'a> {
    fn new(inner: std::str::Split<'a, char>) -> SplitIteratorWithPosition<'a> {
        SplitIteratorWithPosition {
            inner: inner,
            position: 0
        }
    }

    fn string_position(&self) -> usize {
        self.position
    }
}

impl<'a> Iterator for SplitIteratorWithPosition<'a> {
    type Item = &'a str;

    fn next(&mut self) -> Option<&'a str> {
        match self.inner.next() {
            Some(x) => {
                self.position += x.len() + 1;
                Some(x)
            },
            None => None
        }
    }
}

fn parse_instance_info(addr: IpAddr, string: &str) -> Result<(InstanceInfo, usize), BrowserProtocolError> {
    #[inline]
    fn expect_next<'a, T: Iterator<Item = &'a str>>(iterator: &mut T, identifier: &str, field: BrowserProtocolField) -> Result<(), BrowserProtocolError> {
        iterator
            .next()
            .ok_or_else(|| BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::Identifier(field),
                found: BrowserProtocolToken::EndOfMessage
            })
            .and_then(|x| {
                if x == identifier { 
                    Ok(()) 
                } else {
                    Err(BrowserProtocolError::UnexpectedToken {
                        expected: BrowserProtocolToken::Identifier(field),
                        found: BrowserProtocolToken::Literal(x.to_string())
                    })
                }
            })
    }

    fn consume_next<'a, T: Iterator<Item = &'a str>>(iterator: &mut T, value_name: BrowserProtocolField) -> Result<&'a str, BrowserProtocolError> {
        iterator.next()
            .ok_or_else(|| BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::ValueOf(value_name),
                found: BrowserProtocolToken::EndOfMessage
            })
    }

    let mut iterator = SplitIteratorWithPosition::new(string.split(';'));

    // Instance information
    expect_next(&mut iterator, "ServerName", BrowserProtocolField::ServerName)?;
    let server_name = consume_next(&mut iterator, BrowserProtocolField::ServerName)?;
    expect_next(&mut iterator, "InstanceName", BrowserProtocolField::InstanceName)?;
    let instance_name = consume_next(&mut iterator, BrowserProtocolField::InstanceName)?;
    expect_next(&mut iterator, "IsClustered", BrowserProtocolField::IsClustered)?;
    let is_clustered_str = consume_next(&mut iterator, BrowserProtocolField::IsClustered)?;
    let is_clustered = match is_clustered_str {
        "Yes" => true,
        "No" => false,
        v => return Err(BrowserProtocolError::UnexpectedToken {
            expected: BrowserProtocolToken::ValueOf(BrowserProtocolField::IsClustered),
            found: BrowserProtocolToken::Literal(v.to_string())
        })
    };
    expect_next(&mut iterator, "Version", BrowserProtocolField::Version)?;
    let version = consume_next(&mut iterator, BrowserProtocolField::Version)?;

    // Supported protocols
    let mut np_info: Option<NamedPipeInfo> = None;
    let mut tcp_info: Option<TcpInfo> = None; 
    let mut via_info: Option<ViaInfo> = None;
    let mut rpc_info: Option<RpcInfo> = None;
    let mut spx_info: Option<SpxInfo> = None;
    let mut adsp_info: Option<AdspInfo> = None;
    let mut bv_info: Option<BvInfo> = None;

    loop {
        match iterator.next() {
            Some("np") => {
                let pipe_name = consume_next(&mut iterator, BrowserProtocolField::NamedPipeName)?;
                np_info = Some(NamedPipeInfo {
                    name: pipe_name.to_owned()
                });
            },
            Some("tcp") => {
                let port_str = consume_next(&mut iterator, BrowserProtocolField::TcpPort)?;
                let port: u16 = port_str.parse()
                    .map_err(|_| 
                        BrowserProtocolError::UnexpectedToken {
                            expected: BrowserProtocolToken::TcpPort,
                            found: BrowserProtocolToken::Literal(port_str.to_string())
                        }
                    )?;
                tcp_info = Some(TcpInfo {
                    port
                });
            },
            Some("via") => {
                let parameters = consume_next(&mut iterator, BrowserProtocolField::ViaMachineName)?;
                let comma_idx = parameters.find(',')
                    .ok_or_else(|| BrowserProtocolError::UnexpectedToken {
                        expected: BrowserProtocolToken::ViaParameters,
                        found: BrowserProtocolToken::Literal(parameters.to_string())
                    })?;
                let machine_name = &parameters[0..comma_idx];
                let mut nic_port_parts = (&parameters[(comma_idx + 1)..]).split(&[',', ':'][..]);
                let mut addresses = Vec::new();
                while let Some(nic) = nic_port_parts.next() {
                    let port = nic_port_parts.next().ok_or_else(|| BrowserProtocolError::UnexpectedToken {
                        expected: BrowserProtocolToken::ViaParameters,
                        found: BrowserProtocolToken::Literal(parameters.to_string())
                    })?;
                    addresses.push(ViaAddress {
                        nic: nic.to_owned(),
                        port: port.to_owned()
                    });
                }
                via_info = Some(ViaInfo {
                    machine_name: machine_name.to_owned(),
                    addresses
                });
            },
            Some("rpc") => {
                let computer_name = consume_next(&mut iterator, BrowserProtocolField::RpcComputerName)?;
                rpc_info = Some(RpcInfo {
                    computer_name: computer_name.to_owned()
                });
            },
            Some("spx") => {
                let service_name = consume_next(&mut iterator, BrowserProtocolField::SpxServiceName)?;
                spx_info = Some(SpxInfo {
                    service_name: service_name.to_owned()
                });
            },
            Some("adsp") => {
                let object_name = consume_next(&mut iterator, BrowserProtocolField::AppleTalkObjectName)?;
                adsp_info = Some(AdspInfo {
                    object_name: object_name.to_owned()
                });
            },
            Some("bv") => {
                let item_name = consume_next(&mut iterator, BrowserProtocolField::BvItemName)?;
                let group_name = consume_next(&mut iterator, BrowserProtocolField::BvGroupName)?;
                let org_name = consume_next(&mut iterator, BrowserProtocolField::BvOrgName)?;
                bv_info = Some(BvInfo {
                    item_name: item_name.to_owned(),
                    group_name: group_name.to_owned(),
                    org_name: org_name.to_owned()
                });
            },
            Some("") => break,
            Some(x) => return Err(BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::EndpointIdentifierOrSemicolon,
                found: BrowserProtocolToken::Literal(x.to_string())
            }),
            None => return Err(BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::EndpointIdentifierOrSemicolon,
                found: BrowserProtocolToken::EndOfMessage
            })
        };
    }

    let consumed = iterator.string_position();

    Ok((InstanceInfo {
        addr,
        server_name: server_name.to_owned(),
        instance_name: instance_name.to_owned(),
        is_clustered,
        version: version.to_owned(),
        np_info,
        tcp_info,
        via_info,
        rpc_info,
        spx_info,
        adsp_info,
        bv_info
    }, consumed))
}