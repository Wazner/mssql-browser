use tokio::net::UdpSocket;
use std::net::{ IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr };

/// Maximum length of an instance name
pub const MAX_INSTANCE_NAME_LEN: usize = 32;

/// The CLNT_BCAST_EX packet is a broadcast or multicast request that is generated by clients that are trying 
/// to identify the list of database instances on the network and their network protocol connection information.
const CLNT_BCAST_EX: u8 = 0x02;

/// The CLNT_UCAST_EX packet is a unicast request that is generated by clients that are trying to identify 
/// the list of database instances and their network protocol connection information installed on a single machine. 
const CLNT_UCAST_EX: u8 = 0x03;

/// The CLNT_UCAST_INST packet is a request for information related to a specific instance.
const CLNT_UCAST_INST: u8 = 0x04;

/// The CLNT_UCAST_DAC packet request is used to determine the TCP [RFC793] port on which the 
/// Microsoft SQL Server dedicated administrator connection (DAC) endpoint is listening.
const CLNT_UCAST_DAC: u8 = 0x0F;

/// The server responds to all client requests with an SVR_RESP. 
const SVR_RESP: u8 = 0x05;

/// An error that can be returned from the different browser operations
#[derive(Debug)]
pub enum BrowserError {
    /// The underlying `tokio::net::UdpSocket` failed to bind.
    BindFailed(tokio::io::Error),

    /// Enabling the broadcast option on the `tokio::net::UdpSocket` failed.
    SetBroadcastFailed(tokio::io::Error),

    /// Sending the request datagram failed.
    SendFailed(tokio::io::Error),

    /// Locking the `tokio::net::UdpSocket` to a specific endpoint via `tokio::net::UdpSocket::connect` failed.
    ConnectFailed(SocketAddr, tokio::io::Error),

    /// Receiving a datagram failed.
    ReceiveFailed(tokio::io::Error),

    /// The given instance name is too long.
    InstanceNameTooLong,

    /// The server send back an invalid response.
    ProtocolError(BrowserProtocolError)
}

/// Received an unexpected response from the server
#[derive(Debug)]
pub enum BrowserProtocolError {
    /// An unexpected token was received from the server
    UnexpectedToken {
        /// The token that was expected at this location
        expected: BrowserProtocolToken,

        /// The token that was found
        found: BrowserProtocolToken
    },

    /// The length of the datagram does not match the length
    /// specified in the packet header.
    LengthMismatch {
        /// The size, in bytes, of the datagram
        datagram: usize,

        /// The size, in bytes, specified in the packet header
        header: usize
    },

    /// Unexpected MBCS string encoding found in the received message
    InvalidUtf8(std::str::Utf8Error),

    /// There was extraneous data after the parsed message
    ExtraneousData(Vec<u8>)
}

impl std::fmt::Display for BrowserProtocolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use BrowserProtocolError::*;

        match self {
            UnexpectedToken { expected, found } 
                => write!(f, "expected {}, but found {}", expected, found),
            LengthMismatch { datagram, header }
                => write!(f, "mismatch between datagram size {} bytes and size specified in header {} bytes", datagram, header),
            InvalidUtf8(err)
                => err.fmt(f),
            ExtraneousData(data)
                => write!(f, "{} unexpected trailing bytes", data.len())
        }
    }
}

/// The value that was expected.
#[derive(Debug)]
pub enum BrowserProtocolToken {
    /// End of the datagram
    EndOfMessage,

    /// A literal string
    Literal(String),

    /// The message identifier specified in the header
    MessageIdentifier(u8),

    /// The message length specified in the header
    MessageLength,

    DacVersion(u8),
    DacPort,
    Identifier(BrowserProtocolField),
    ValueOf(BrowserProtocolField),
    TcpPort,
    ViaParameters,
    EndpointIdentifierOrSemicolon
}

impl std::fmt::Display for BrowserProtocolToken {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use BrowserProtocolToken::*;

        match self {
            EndOfMessage => write!(f, "end of message"),
            Literal(s) => write!(f, "'{}'", s),
            MessageIdentifier(v) => write!(f, "message identifier {:#X}", v),
            MessageLength => write!(f, "message length"),
            DacVersion(v) => write!(f, "dac version {}", v),
            DacPort => write!(f, "dac port"),
            Identifier(field) => write!(f, "identifier for field {:?}", field),
            ValueOf(field) => write!(f, "value for field {:?}", field),
            TcpPort => write!(f, "tcp port"),
            ViaParameters => write!(f, "via parameters"),
            EndpointIdentifierOrSemicolon => write!(f, "endpoint identifier or semicolon")
        }
    }  
}

/// Different fields found in a browser response
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum BrowserProtocolField {
    ServerName,
    InstanceName,
    IsClustered,
    Version,

    NamedPipeName,
    TcpPort,
    ViaMachineName,
    RpcComputerName,
    SpxServiceName,
    AppleTalkObjectName,
    BvItemName,
    BvGroupName,
    BvOrgName
}

impl std::fmt::Display for BrowserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use BrowserError::*;

        match self {
            BindFailed(err) => write!(f, "bind failed: {}", err),
            SetBroadcastFailed(err) => write!(f, "enabling broadcast option failed: {}", err),
            SendFailed(err) => write!(f, "sending of datagram failed: {}", err),
            ConnectFailed(endpoint, err) => write!(f, "connect to endpoint '{}' failed: {}", endpoint, err),
            ReceiveFailed(err) => write!(f, "receiving of datagram failed: {}", err),
            InstanceNameTooLong => write!(f, "specified instance name is longer than {} bytes", MAX_INSTANCE_NAME_LEN),
            ProtocolError(e) => write!(f, "protocol error: {}", e)
        }
    }
}

impl std::error::Error for BrowserError {}

/// Information send in a browser protocol response
/// See https://docs.microsoft.com/en-us/openspecs/windows_protocols/mc-sqlr/2e1560c9-5097-4023-9f5e-72b9ff1ec3b1
#[derive(Debug)]
pub struct InstanceInfo {
    /// The address of the instance
    pub addr: IpAddr,

    /// The name of the server. The SERVERNAME MUST be no greater than 255 bytes.
    pub server_name: String,

    /// A text string that represents the name of the server instance being described. 
    /// The INSTANCENAME MUST be no greater than 255 bytes but SHOULD be no greater than 16 MBCS characters.
    pub instance_name: String,

    pub is_clustered: bool,
    
    /// A text string that conveys the version of the server instance. The VERSION_STRING MUST be no greater than 16 bytes. 
    /// VERSION_STRING MUST NOT be empty and MUST appear as follows: VERSION_STRING=1*[0-9"."]
    pub version: String,

    pub np_info: Option<NamedPipeInfo>,
    pub tcp_info: Option<TcpInfo>,
    pub via_info: Option<ViaInfo>,
    pub rpc_info: Option<RpcInfo>,
    pub spx_info: Option<SpxInfo>,
    pub adsp_info: Option<AdspInfo>,
    pub bv_info: Option<BvInfo>
}

/// Information about the named pipe endpoint
#[derive(Debug)]
pub struct NamedPipeInfo {
    /// A text string that represents the pipe name.
    pub name: String
}

/// Information about the Tcp endpoint
#[derive(Debug)]
pub struct TcpInfo {
    /// A text string that represents the decimal value of the TCP port that is used to connect to the requested server instance.
    /// TCP_PORT SHOULD be a valid TCP port as specified in [RFC793]
    pub port: u16
}

/// Information about the Virtual Interface Architecture endpoint
#[derive(Debug)]
pub struct ViaInfo {
    /// A text string that MUST be no greater than 15 bytes and that represents the NetBIOS name of a machine where the server resides.
    pub machine_name: String,
    
    /// The VIA addresses specified
    pub addresses: Vec<ViaAddress>
}

/// A combination of NIC name and port.
#[derive(Debug)]
pub struct ViaAddress {
    /// A text string that represents the VIA network interface card (NIC) identifier. 
    /// VIANIC SHOULD be a valid VIA Adapter NIC number [VIA2002].
    pub nic: String,

    /// A text string that represents the decimal value of the VIA NIC's port. 
    /// VIAPORT SHOULD be a valid VIA Adapter port number [VIA2002].
    pub port: String
}

/// Contains information about an RPC endpoint
#[derive(Debug)]
pub struct RpcInfo {
    /// The name of the computer to connect to. SHOULD be no more than 127 MBCS characters.
    pub computer_name: String
}

/// Contains information about an SPX service endpoint
#[derive(Debug)]
pub struct SpxInfo {
    /// The SPX service name of the server. 
    /// MUST NOT be greater than 1,024 bytes and SHOULD be no more than 127 MBCS characters.
    pub service_name: String
}

/// Contains information about an AppleTalk endpoint
#[derive(Debug)]
pub struct AdspInfo {
    /// The AppleTalk service object name. SHOULD be no more than 127 MBCS characters.
    pub object_name: String
}

/// Contains information about an Banyan VINES endpoint
#[derive(Debug)]
pub struct BvInfo {
    /// The Banyan VINES item name. SHOULD be no more than 127 MBCS characters.
    pub item_name: String,
    
    /// The Banyan VINES group name. SHOULD be no more than 127 MBCS characters.
    pub group_name: String,
    
    /// The Banyan VINES organization name. SHOULD be no more than 127 MBCS characters.
    pub org_name: String
}

/// Supplies instance information as they arrive
pub struct AsyncInstanceIterator {
    socket: UdpSocket,
    buffer: Vec<u8>,

    current_remote_addr: IpAddr,
    current_offset: usize
}

impl AsyncInstanceIterator {
    /// Gets the next received instance information. You can call this method multiple
    /// times to receive information about multiple instances until it returns Ok(None).
    pub async fn next(&mut self) -> Result<Option<InstanceInfo>, BrowserError> {
        loop {
            if self.current_offset >= self.buffer.len() {
                // Need to receive a new packet
                // TODO: Find a way to determine buffer size based on FIONREAD
                // once/if ever tokio supports it
                self.buffer.resize_with(65535 + 3, Default::default);

                let (bytes_received, remote_addr) = self.socket.recv_from(&mut self.buffer)
                    .await
                    .map_err(BrowserError::ReceiveFailed)?;

                self.current_remote_addr = remote_addr.ip();

                if bytes_received < 3 || self.buffer[0] != SVR_RESP {
                    self.current_offset = std::usize::MAX;
                    continue;
                }

                let resp_data_len = u16::from_le_bytes([self.buffer[1], self.buffer[2]]);
                if resp_data_len as usize != bytes_received - 3 {
                    self.current_offset = std::usize::MAX;
                    continue;
                }

                // Validate that the buffer is valid utf-8
                // TODO: Decode mbcs string
                if std::str::from_utf8(&self.buffer[3..]).is_err() {
                    self.current_offset = std::usize::MAX;
                    continue;
                }

                self.buffer.truncate(bytes_received);
                self.current_offset = 3;
            }

            // UNSAFE: Buffer is already validated to be valid utf-8 when the iterator was created
            let as_str = unsafe { std::str::from_utf8_unchecked(&self.buffer[self.current_offset..]) };

            let (instance, consumed) = match parse_instance_info(self.current_remote_addr, as_str) {
                Ok(x) => x,
                Err(_) => {
                    self.current_offset = std::usize::MAX;
                    continue;
                }
            };

            self.current_offset += consumed;
            return Ok(Some(instance));
        }
    }
}

/// Discovers any SQL Server instances running on hosts reached by
/// the given multicast address.
/// 
/// # Arguments
/// * `multicast_addr` - A multicast address to which to broadcast the browse datagram.
///                      This can be the Ipv4 BROADCAST address, or a Ipv6 multicast address.
pub async fn browse(multicast_addr: IpAddr) -> Result<AsyncInstanceIterator, BrowserError> {
    let local_addr = if multicast_addr.is_ipv4() {
        IpAddr::V4(Ipv4Addr::UNSPECIFIED)
    }
    else {
        IpAddr::V6(Ipv6Addr::UNSPECIFIED)
    };

    let bind_to = SocketAddr::new(local_addr, 0);
    let mut socket = UdpSocket::bind(&bind_to).await
        .map_err(BrowserError::BindFailed)?;

    socket.set_broadcast(true)
        .map_err(BrowserError::SetBroadcastFailed)?;

    let buffer = [CLNT_BCAST_EX]; 
    let remote = SocketAddr::new(multicast_addr, 1434);
    socket.send_to(&buffer, &remote).await
        .map_err(BrowserError::SendFailed)?;

    Ok(AsyncInstanceIterator {
        socket: socket,
        buffer: Vec::new(),
        current_remote_addr: IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)),
        current_offset: 0
    })
}

/// Iterates over the instances returned by a single host
pub struct InstanceIterator {
    remote_addr: IpAddr,
    buffer: Vec<u8>,
    offset: usize
}

impl InstanceIterator {
    /// Gets the next received instance information. You can call this method multiple
    /// times to receive information about multiple instances until it returns Ok(None).
    pub fn next(&mut self) -> Result<Option<InstanceInfo>, BrowserError> {
        if self.offset == self.buffer.len() {
            return Ok(None);
        }

        // UNSAFE: Buffer is already validated to be valid utf-8 when the iterator was created
        let as_str = unsafe { std::str::from_utf8_unchecked(&self.buffer[self.offset..]) };
        let (instance, consumed) = parse_instance_info(self.remote_addr, as_str)
            .map_err(|e| BrowserError::ProtocolError(e))?;

        self.offset += consumed;
        Ok(Some(instance))
    }
}

/// Discovers any SQL Server instances running on the given host
/// 
/// # Arguments
/// * `remote_addr` - The address of the remote host of which to retrieve information
///                   about the instances running on it.
pub async fn browse_host(remote_addr: IpAddr) -> Result<InstanceIterator, BrowserError> {
    let local_addr = if remote_addr.is_ipv4() {
        IpAddr::V4(Ipv4Addr::UNSPECIFIED)
    }
    else {
        IpAddr::V6(Ipv6Addr::UNSPECIFIED)
    };

    let bind_to = SocketAddr::new(local_addr, 0);
    let mut socket = UdpSocket::bind(&bind_to).await
        .map_err(BrowserError::BindFailed)?;

    let remote = SocketAddr::new(remote_addr, 1434);
    socket.connect(&remote).await
        .map_err(|e| BrowserError::ConnectFailed(remote, e))?;

    let buffer = [CLNT_UCAST_EX];
    socket.send_to(&buffer, &remote).await
        .map_err(BrowserError::SendFailed)?;

    let mut buffer = Vec::with_capacity(65535 + 3);
    
    buffer.resize_with(buffer.capacity(), Default::default);

    let bytes_received = socket.recv(&mut buffer).await
        .map_err(BrowserError::ReceiveFailed)?;

    if bytes_received < 1 {
        return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
            expected: BrowserProtocolToken::MessageIdentifier(SVR_RESP),
            found: BrowserProtocolToken::EndOfMessage   
        }));
    }

    if buffer[0] != SVR_RESP {
        return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
            expected: BrowserProtocolToken::MessageIdentifier(SVR_RESP),
            found: BrowserProtocolToken::MessageIdentifier(buffer[0])
        }));
    }

    if bytes_received < 3 {
        return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
            expected: BrowserProtocolToken::MessageLength,
            found: BrowserProtocolToken::EndOfMessage
        }));
    }

    let resp_data_len = u16::from_le_bytes([buffer[1], buffer[2]]);
    if resp_data_len as usize != bytes_received - 3 {
        return Err(BrowserError::ProtocolError(BrowserProtocolError::LengthMismatch {
            datagram: bytes_received,
            header: (resp_data_len + 3) as usize
        }));
    }

    buffer.truncate(bytes_received);

    // Validate that the buffer is valid utf-8
    // TODO: Decode mbcs string
    std::str::from_utf8(&buffer[3..])
        .map_err(|e| BrowserError::ProtocolError(BrowserProtocolError::InvalidUtf8(e)))?;

    Ok(InstanceIterator {
        remote_addr,
        buffer,
        offset: 3
    })
}

/// Gets information about the given instance.
/// 
/// # Arguments
/// * `remote_addr` - The address of the remote host on which the instance is running.
/// * `instance_name` - The name of the instance, must be less than `MAX_INSTANCE_NAME_LEN` characters.
pub async fn browse_instance(remote_addr: IpAddr, instance_name: &str) -> Result<InstanceInfo, BrowserError> {
    if instance_name.len() > MAX_INSTANCE_NAME_LEN {
        return Err(BrowserError::InstanceNameTooLong);
    }

    let local_addr = if remote_addr.is_ipv4() {
        IpAddr::V4(Ipv4Addr::UNSPECIFIED)
    }
    else {
        IpAddr::V6(Ipv6Addr::UNSPECIFIED)
    };

    let bind_to = SocketAddr::new(local_addr, 0);
    let mut socket = UdpSocket::bind(&bind_to).await
        .map_err(BrowserError::BindFailed)?;

    let remote = SocketAddr::new(remote_addr, 1434);
    socket.connect(&remote).await
        .map_err(|e| BrowserError::ConnectFailed(remote, e))?;

    let mut buffer = [0u8; 1 + MAX_INSTANCE_NAME_LEN + 1];
    buffer[0] = CLNT_UCAST_INST;
    buffer[1..(1+instance_name.len())].copy_from_slice(instance_name.as_bytes()); // TODO: Encode as mbcs string
    let buffer_len = 2 + instance_name.len();
    socket.send_to(&buffer[0..buffer_len], &remote).await
        .map_err(BrowserError::SendFailed)?;

    let mut buffer = [0u8; 3 + 1024];

    let bytes_received = socket.recv(&mut buffer).await
        .map_err(BrowserError::ReceiveFailed)?;

    if bytes_received < 1 {
        return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
            expected: BrowserProtocolToken::MessageIdentifier(SVR_RESP),
            found: BrowserProtocolToken::EndOfMessage   
        }));
    }

    if buffer[0] != SVR_RESP {
        return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
            expected: BrowserProtocolToken::MessageIdentifier(SVR_RESP),
            found: BrowserProtocolToken::MessageIdentifier(buffer[0])   
        }));
    }

    if bytes_received < 3 {
        return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
            expected: BrowserProtocolToken::MessageLength,
            found: BrowserProtocolToken::EndOfMessage
        }));
    }

    let resp_data_len = u16::from_le_bytes([buffer[1], buffer[2]]);
    if resp_data_len as usize != bytes_received - 3 {
        return Err(BrowserError::ProtocolError(BrowserProtocolError::LengthMismatch {
            datagram: bytes_received,
            header: (resp_data_len + 3) as usize
        }));
    }

    // TODO: Decode mbcs string
    let as_str = std::str::from_utf8(&buffer[3..bytes_received]).unwrap();
    let (instance, consumed) = parse_instance_info(remote_addr, &as_str)
        .map_err(|e| BrowserError::ProtocolError(e))?;
    
    if consumed != as_str.len() {
        return Err(BrowserError::ProtocolError(BrowserProtocolError::ExtraneousData(Vec::from(&buffer[(3 + consumed)..]))));
    }

    Ok(instance)
}

/// Contains information about the DAC endpoint of an instance
#[derive(Debug)]
pub struct DacInfo {
    port: u16
}

/// Gets DAC information about the given instance
pub async fn browse_instance_dac(remote_addr: IpAddr, instance_name: &str) -> Result<DacInfo, BrowserError> {
    const VERSION: u8 = 0x01;

    if instance_name.len() > MAX_INSTANCE_NAME_LEN {
        return Err(BrowserError::InstanceNameTooLong);
    }

    let local_addr = if remote_addr.is_ipv4() {
        IpAddr::V4(Ipv4Addr::UNSPECIFIED)
    }
    else {
        IpAddr::V6(Ipv6Addr::UNSPECIFIED)
    };

    let bind_to = SocketAddr::new(local_addr, 0);
    let mut socket = UdpSocket::bind(&bind_to).await
        .map_err(BrowserError::BindFailed)?;

    let remote = SocketAddr::new(remote_addr, 1434);
    socket.connect(&remote).await
        .map_err(|e| BrowserError::ConnectFailed(remote, e))?;
   
    let mut buffer = [0u8; 2 + MAX_INSTANCE_NAME_LEN + 1];
    buffer[0] = CLNT_UCAST_DAC;
    buffer[1] = VERSION;
    buffer[2..(2+instance_name.len())].copy_from_slice(instance_name.as_bytes()); // TODO: Encode as mbcs string
    let buffer_len = 3 + instance_name.len();
    socket.send(&buffer[0..buffer_len]).await
        .map_err(BrowserError::SendFailed)?;

    let mut buffer = [0u8; 6];

    let bytes_received = socket.recv(&mut buffer).await
        .map_err(BrowserError::ReceiveFailed)?;

    if bytes_received < 1 {
        return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
            expected: BrowserProtocolToken::MessageIdentifier(SVR_RESP),
            found: BrowserProtocolToken::EndOfMessage   
        }));
    }

    if buffer[0] != SVR_RESP {
        return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
            expected: BrowserProtocolToken::MessageIdentifier(SVR_RESP),
            found: BrowserProtocolToken::MessageIdentifier(buffer[0])   
        }));
    }

    if bytes_received < 3 {
        return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
            expected: BrowserProtocolToken::MessageLength,
            found: BrowserProtocolToken::EndOfMessage
        }));
    }

    let packet_size = u16::from_le_bytes([buffer[1], buffer[2]]) as usize;
    if packet_size != buffer.len() {
        return Err(BrowserError::ProtocolError(BrowserProtocolError::LengthMismatch {
            datagram: bytes_received,
            header: packet_size
        }));
    }

    if bytes_received < 4 {
        return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
            expected: BrowserProtocolToken::DacVersion(VERSION),
            found: BrowserProtocolToken::EndOfMessage
        }));
    }

    if buffer[3] != VERSION {
        return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
            expected: BrowserProtocolToken::DacVersion(VERSION),
            found: BrowserProtocolToken::DacVersion(buffer[3])
        }));
    }

    if bytes_received < 6 {
        return Err(BrowserError::ProtocolError(BrowserProtocolError::UnexpectedToken {
            expected: BrowserProtocolToken::DacPort,
            found: BrowserProtocolToken::EndOfMessage
        }));
    }

    let port = u16::from_le_bytes([buffer[4], buffer[5]]);
    return Ok(DacInfo { port });
}

struct SplitIteratorWithPosition<'a> {
    inner: std::str::Split<'a, char>,
    position: usize
}

impl<'a> SplitIteratorWithPosition<'a> {
    fn new(inner: std::str::Split<'a, char>) -> SplitIteratorWithPosition<'a> {
        SplitIteratorWithPosition {
            inner: inner,
            position: 0
        }
    }

    fn string_position(&self) -> usize {
        self.position
    }
}

impl<'a> Iterator for SplitIteratorWithPosition<'a> {
    type Item = &'a str;

    fn next(&mut self) -> Option<&'a str> {
        match self.inner.next() {
            Some(x) => {
                self.position += x.len() + 1;
                Some(x)
            },
            None => None
        }
    }
}

fn parse_instance_info(addr: IpAddr, string: &str) -> Result<(InstanceInfo, usize), BrowserProtocolError> {
    #[inline]
    fn expect_next<'a, T: Iterator<Item = &'a str>>(iterator: &mut T, identifier: &str, field: BrowserProtocolField) -> Result<(), BrowserProtocolError> {
        iterator
            .next()
            .ok_or_else(|| BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::Identifier(field),
                found: BrowserProtocolToken::EndOfMessage
            })
            .and_then(|x| {
                if x == identifier { 
                    Ok(()) 
                } else {
                    Err(BrowserProtocolError::UnexpectedToken {
                        expected: BrowserProtocolToken::Identifier(field),
                        found: BrowserProtocolToken::Literal(x.to_string())
                    })
                }
            })
    }

    fn consume_next<'a, T: Iterator<Item = &'a str>>(iterator: &mut T, value_name: BrowserProtocolField) -> Result<&'a str, BrowserProtocolError> {
        iterator.next()
            .ok_or_else(|| BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::ValueOf(value_name),
                found: BrowserProtocolToken::EndOfMessage
            })
    }

    let mut iterator = SplitIteratorWithPosition::new(string.split(';'));

    // Instance information
    expect_next(&mut iterator, "ServerName", BrowserProtocolField::ServerName)?;
    let server_name = consume_next(&mut iterator, BrowserProtocolField::ServerName)?;
    expect_next(&mut iterator, "InstanceName", BrowserProtocolField::InstanceName)?;
    let instance_name = consume_next(&mut iterator, BrowserProtocolField::InstanceName)?;
    expect_next(&mut iterator, "IsClustered", BrowserProtocolField::IsClustered)?;
    let is_clustered_str = consume_next(&mut iterator, BrowserProtocolField::IsClustered)?;
    let is_clustered = match is_clustered_str {
        "Yes" => true,
        "No" => false,
        v => return Err(BrowserProtocolError::UnexpectedToken {
            expected: BrowserProtocolToken::ValueOf(BrowserProtocolField::IsClustered),
            found: BrowserProtocolToken::Literal(v.to_string())
        })
    };
    expect_next(&mut iterator, "Version", BrowserProtocolField::Version)?;
    let version = consume_next(&mut iterator, BrowserProtocolField::Version)?;

    // Supported protocols
    let mut np_info: Option<NamedPipeInfo> = None;
    let mut tcp_info: Option<TcpInfo> = None; 
    let mut via_info: Option<ViaInfo> = None;
    let mut rpc_info: Option<RpcInfo> = None;
    let mut spx_info: Option<SpxInfo> = None;
    let mut adsp_info: Option<AdspInfo> = None;
    let mut bv_info: Option<BvInfo> = None;

    loop {
        match iterator.next() {
            Some("np") => {
                let pipe_name = consume_next(&mut iterator, BrowserProtocolField::NamedPipeName)?;
                np_info = Some(NamedPipeInfo {
                    name: pipe_name.to_owned()
                });
            },
            Some("tcp") => {
                let port_str = consume_next(&mut iterator, BrowserProtocolField::TcpPort)?;
                let port: u16 = port_str.parse()
                    .map_err(|_| 
                        BrowserProtocolError::UnexpectedToken {
                            expected: BrowserProtocolToken::TcpPort,
                            found: BrowserProtocolToken::Literal(port_str.to_string())
                        }
                    )?;
                tcp_info = Some(TcpInfo {
                    port
                });
            },
            Some("via") => {
                let parameters = consume_next(&mut iterator, BrowserProtocolField::ViaMachineName)?;
                let comma_idx = parameters.find(',')
                    .ok_or_else(|| BrowserProtocolError::UnexpectedToken {
                        expected: BrowserProtocolToken::ViaParameters,
                        found: BrowserProtocolToken::Literal(parameters.to_string())
                    })?;
                let machine_name = &parameters[0..comma_idx];
                let mut nic_port_parts = (&parameters[(comma_idx + 1)..]).split(&[',', ':'][..]);
                let mut addresses = Vec::new();
                while let Some(nic) = nic_port_parts.next() {
                    let port = nic_port_parts.next().ok_or_else(|| BrowserProtocolError::UnexpectedToken {
                        expected: BrowserProtocolToken::ViaParameters,
                        found: BrowserProtocolToken::Literal(parameters.to_string())
                    })?;
                    addresses.push(ViaAddress {
                        nic: nic.to_owned(),
                        port: port.to_owned()
                    });
                }
                via_info = Some(ViaInfo {
                    machine_name: machine_name.to_owned(),
                    addresses
                });
            },
            Some("rpc") => {
                let computer_name = consume_next(&mut iterator, BrowserProtocolField::RpcComputerName)?;
                rpc_info = Some(RpcInfo {
                    computer_name: computer_name.to_owned()
                });
            },
            Some("spx") => {
                let service_name = consume_next(&mut iterator, BrowserProtocolField::SpxServiceName)?;
                spx_info = Some(SpxInfo {
                    service_name: service_name.to_owned()
                });
            },
            Some("adsp") => {
                let object_name = consume_next(&mut iterator, BrowserProtocolField::AppleTalkObjectName)?;
                adsp_info = Some(AdspInfo {
                    object_name: object_name.to_owned()
                });
            },
            Some("bv") => {
                let item_name = consume_next(&mut iterator, BrowserProtocolField::BvItemName)?;
                let group_name = consume_next(&mut iterator, BrowserProtocolField::BvGroupName)?;
                let org_name = consume_next(&mut iterator, BrowserProtocolField::BvOrgName)?;
                bv_info = Some(BvInfo {
                    item_name: item_name.to_owned(),
                    group_name: group_name.to_owned(),
                    org_name: org_name.to_owned()
                });
            },
            Some("") => break,
            Some(x) => return Err(BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::EndpointIdentifierOrSemicolon,
                found: BrowserProtocolToken::Literal(x.to_string())
            }),
            None => return Err(BrowserProtocolError::UnexpectedToken {
                expected: BrowserProtocolToken::EndpointIdentifierOrSemicolon,
                found: BrowserProtocolToken::EndOfMessage
            })
        };
    }

    let consumed = iterator.string_position();

    Ok((InstanceInfo {
        addr,
        server_name: server_name.to_owned(),
        instance_name: instance_name.to_owned(),
        is_clustered,
        version: version.to_owned(),
        np_info,
        tcp_info,
        via_info,
        rpc_info,
        spx_info,
        adsp_info,
        bv_info
    }, consumed))
}